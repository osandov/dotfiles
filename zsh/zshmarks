# Directory to create marks in by default.
DEFAULT_MARKDIR=~

# List of directories to store marks in. Any files created under the parent
# directory will be created in that directory. This is mostly useful when a
# directory is shared or synced and you want your marks to exist across
# machines.
MARKDIRS=("$DEFAULT_MARKDIR")

# Sync marks in Dropbox.
for DROPBOX_DIR in ~/Dropbox*(/N); do
	MARKDIRS=("$DROPBOX_DIR" $MARKDIRS)
done

# Create all of the mark directories.
for MARKDIR in $MARKDIRS; do
	mkdir -p "$MARKDIR/.marks"
done

# Add a new mark. The mark will be added to the first mark directory under
# which it exits or, failing that, the default mark directory.
mark () {
	if [[ $# -lt 1 || $# -gt 2 ]]; then
		echo "Usage: $0 [TARGET] MARK" >&2
		return 1
	fi

	if [[ $# -eq 2 ]]; then
		if [[ ! -d "$1" ]]; then
			echo "$0: not a directory: $1"
			return 1
		fi

		pushd "$1" > /dev/null
		TARGET="$(pwd)"
		popd > /dev/null
		shift
	else
		TARGET="$(pwd)"
	fi

	if findmark "$1" > /dev/null 2>&1; then
		echo "$0: mark already exists: $1" >&2
		return 1
	fi

	MARKDIR="$DEFAULT_MARKDIR"
	for SUBMARKDIR in $MARKDIRS; do
		if [[ $TARGET =~ ^$SUBMARKDIR/ ]]; then
			MARKDIR="$SUBMARKDIR"
			break
		fi
	done

	echo "$TARGET" > "$MARKDIR/.marks/$1"
}

# List all marks from all mark directories.
marks () {
	if [[ $# -gt 0 ]]; then
		echo "Usage: $0" >&2
		return 1
	fi

	find ${^MARKDIRS}/.marks -type f | while read -r MARKFILE; do
		printf "%s -> %s\n" "$MARKFILE:t" "$(cat "$MARKFILE")"
	done | sort
}

# Print the location of the mark file itself.
findmark () {
	if [[ $# -ne 1 ]]; then
		echo "Usage: $0 MARK" >&2
		return 1
	fi

	for MARKDIR in $MARKDIRS; do
		if [[ -f $MARKDIR/.marks/$1 ]]; then
			echo "$MARKDIR/.marks/$1"
			return 0
		fi
	done

	echo "$0: no such mark: $1" >&2
	return 1
}

# Read the target of a mark.
readmark () {
	if [[ $# -lt 1 ]]; then
		echo "Usage: $0 MARK..." >&2
		return 1
	fi

	error=0
	while [ $# -gt 0 ]; do
		MARK="$(findmark "$1")"
		if [[ $? -eq 0 ]]; then
			cat "$MARK"
		else
			error=1
		fi
		shift
	done
	return error
}

# Change directories to a mark.
jump () {
	if [[ $# -ne 1 ]]; then
		echo "Usage: $0 MARK" >&2
		return 1
	fi

	TARGET="$(readmark "$1")"
	if [[ $? -eq 0 ]]; then
		cd "$TARGET"
	else
		return 1
	fi
}

# Remove a mark.
unmark () {
	if [[ $# -lt 1 ]]; then
		echo "Usage: $0 MARK..." >&2
		return 1
	fi

	error=0
	while [ $# -gt 0 ]; do
		MARK="$(findmark "$1")"
		if [[ $? -eq 0 ]]; then
			rm -i "$MARK"
		else
			error=1
		fi
		shift
	done
	return error
}
