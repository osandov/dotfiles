# Directory to create marks in by default.
DEFAULT_MARKDIR=~

# List of directories to store marks in. Any files created under the parent
# directory will be created in that directory. This is mostly useful when a
# directory is shared or synced and you want your marks to exist across
# machines.
MARKDIRS=("$DEFAULT_MARKDIR")

# Sync marks in Dropbox.
while IFS= read -r -d '' markdir; do
	MARKDIRS=("$markdir" "${MARKDIRS[@]}")
done < <(find ~ -mindepth 1 -maxdepth 1 -type d -name 'Dropbox*' -print0)

# Create all of the mark directories.
for markdir in "${MARKDIRS[@]}"; do
	mkdir -p "$markdir/.marks"
done

unset markdir

mark() {
	local usage="\
usage: $0 [-f] [TARGET] MARK

Add a new mark named MARK which points to the directory TARGET (the current
directory by default).

The mark is created in the first mark directory under which it exits or,
failing that, the default mark directory.

options:
  -f    if a mark with the same name exists, remove it
  -h    show this help message and exit"
	local force
	while getopts fh name; do
		case "$name" in
		f)
			force=1
			;;
		h)
			echo "$usage"
			return 0
			;;
		?)
			echo "$usage" >&2
			return 2
			;;
		esac
	done
	shift $((OPTIND - 1))
	if [[ $# -lt 1 || $# -gt 2 ]]; then
		echo "$usage" >&2
		return 2
	fi

	local target
	if [[ $# -eq 2 ]]; then
		pushd "$1" > /dev/null || return 1
		target="$(pwd)"
		popd > /dev/null || return 1
		shift
	else
		target="$(pwd)"
	fi

	local existing
	if existing="$(findmark "$1" 2> /dev/null)"; then
		if [[ -z $force ]]; then
			echo "$0: mark already exists: $1" >&2
			return 1
		elif ! rm -f "$existing"; then
			return 1
		fi
	fi

	local markdir="$DEFAULT_MARKDIR"
	local submarkdir
	for submarkdir in "${MARKDIRS[@]}"; do
		if [[ $target == "$submarkdir/"* ]]; then
			markdir="$submarkdir"
			break
		fi
	done

	echo "$target" > "$markdir/.marks/$1"
}

marks() {
	local usage="\
usage: $0

List all marks from all mark directories.

options:
  -n    list only the mark names
  -h    show this help message and exit"
	local actions=(-printf '%P -> ' -exec cat {} \;)
	while getopts nh name; do
		case "$name" in
		n)
			actions=(-printf '%P\n')
			;;
		h)
			echo "$usage"
			return 0
			;;
		?)
			echo "$usage" >&2
			return 2
			;;
		esac
	done
	shift $((OPTIND - 1))
	if [[ $# -gt 0 ]]; then
		echo "$usage" >&2
		return 2
	fi

	find "${MARKDIRS[@]/%//.marks}" -mindepth 1 -maxdepth 1 -type f \
		"${actions[@]}" | sort
}

findmark() {
	local usage="\
usage: $0 MARK

Print the location of the mark file for MARK."
	while getopts h name; do
		case "$name" in
		h)
			echo "$usage"
			return 0
			;;
		?)
			echo "$usage" >&2
			return 2
			;;
		esac
	done
	shift $((OPTIND - 1))
	if [[ $# -ne 1 ]]; then
		echo "$usage" >&2
		return 2
	fi

	local markdir
	for markdir in "${MARKDIRS[@]}"; do
		if [[ -f $markdir/.marks/$1 ]]; then
			echo "$markdir/.marks/$1"
			return 0
		fi
	done

	echo "$0: no such mark: $1" >&2
	return 1
}

readmark() {
	local usage="\
usage: $0 MARK...

Print the target of one or more marks."
	while getopts h name; do
		case "$name" in
		h)
			echo "$usage"
			return 0
			;;
		?)
			echo "$usage" >&2
			return 2
			;;
		esac
	done
	shift $((OPTIND - 1))
	if [[ $# -lt 1 ]]; then
		echo "$usage" >&2
		return 2
	fi

	local mark
	local error=0
	while [[ $# -gt 0 ]]; do
		if ! mark="$(findmark "$1")" || ! cat "$mark"; then
			error=1
		fi
		shift
	done
	return $error
}

jump() {
	local usage="\
usage: $0 MARK

Change directories to the target of MARK."
	while getopts h name; do
		case "$name" in
		h)
			echo "$usage"
			return 0
			;;
		?)
			echo "$usage" >&2
			return 2
			;;
		esac
	done
	shift $((OPTIND - 1))
	if [[ $# -ne 1 ]]; then
		echo "$usage" >&2
		return 2
	fi

	local target
	target="$(readmark "$1")" && cd "$target"
}

unmark() {
	local usage="\
usage: $0 MARK...

Remove one or more marks."
	while getopts h name; do
		case "$name" in
		h)
			echo "$usage"
			return 0
			;;
		?)
			echo "$usage" >&2
			return 2
			;;
		esac
	done
	shift $((OPTIND - 1))
	if [[ $# -lt 1 ]]; then
		echo "$usage" >&2
		return 2
	fi

	local mark
	local error=0
	while [[ $# -gt 0 ]]; do
		if ! mark="$(findmark "$1")" || ! rm -i "$mark"; then
			error=1
		fi
		shift
	done
	return $error
}
