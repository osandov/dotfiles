# Directory to create marks in by default.
DEFAULT_MARKDIR=~

# List of directories to store marks in. Any files created under the parent
# directory will be created in that directory. This is mostly useful when a
# directory is shared or synced and you want your marks to exist across
# machines.
MARKDIRS=("$DEFAULT_MARKDIR")

function () {
	# Sync marks in Dropbox.
	local dropbox_dir
	for dropbox_dir in ~/Dropbox*(/N); do
		MARKDIRS=("$dropbox_dir" $MARKDIRS)
	done

	# Create all of the mark directories.
	local markdir
	for markdir in $MARKDIRS; do
		mkdir -p "$markdir/.marks"
	done
}

# Add a new mark. The mark will be added to the first mark directory under
# which it exits or, failing that, the default mark directory.
mark () {
	if [[ $# -lt 1 || $# -gt 2 ]]; then
		echo "Usage: $0 [TARGET] MARK" >&2
		return 1
	fi

	local target
	if [[ $# -eq 2 ]]; then
		if [[ ! -d "$1" ]]; then
			echo "$0: not a directory: $1"
			return 1
		fi

		pushd "$1" > /dev/null
		target="$(pwd)"
		popd > /dev/null
		shift
	else
		target="$(pwd)"
	fi

	if findmark "$1" > /dev/null 2>&1; then
		echo "$0: mark already exists: $1" >&2
		return 1
	fi

	local markdir="$DEFAULT_MARKDIR"
	local submarkdir
	for submarkdir in $MARKDIRS; do
		if [[ $target =~ ^$submarkdir/ ]]; then
			markdir="$submarkdir"
			break
		fi
	done

	echo "$target" > "$markdir/.marks/$1"
}

# List all marks from all mark directories.
marks () {
	if [[ $# -gt 0 ]]; then
		echo "Usage: $0" >&2
		return 1
	fi

	local markfile
	find ${^MARKDIRS}/.marks -type f | while read -r markfile; do
		printf "%s -> %s\n" "$markfile:t" "$(cat "$markfile")"
	done | sort
}

# Print the location of the mark file itself.
findmark () {
	if [[ $# -ne 1 ]]; then
		echo "Usage: $0 MARK" >&2
		return 1
	fi

	local markdir
	for markdir in $MARKDIRS; do
		if [[ -f $markdir/.marks/$1 ]]; then
			echo "$markdir/.marks/$1"
			return 0
		fi
	done

	echo "$0: no such mark: $1" >&2
	return 1
}

# Read the target of a mark.
readmark () {
	if [[ $# -lt 1 ]]; then
		echo "Usage: $0 MARK..." >&2
		return 1
	fi

	local mark
	local error=0
	while [[ $# -gt 0 ]]; do
		mark="$(findmark "$1")"
		if [[ $? -eq 0 ]]; then
			cat "$mark"
		else
			error=1
		fi
		shift
	done
	return error
}

# Change directories to a mark.
jump () {
	if [[ $# -ne 1 ]]; then
		echo "Usage: $0 MARK" >&2
		return 1
	fi

	local target
	target="$(readmark "$1")"
	if [[ $? -eq 0 ]]; then
		cd "$target"
	else
		return 1
	fi
}

# Remove a mark.
unmark () {
	if [[ $# -lt 1 ]]; then
		echo "Usage: $0 MARK..." >&2
		return 1
	fi

	local mark
	local error=0
	while [ $# -gt 0 ]; do
		mark="$(findmark "$1")"
		if [[ $? -eq 0 ]]; then
			rm -i "$mark"
		else
			error=1
		fi
		shift
	done
	return error
}
