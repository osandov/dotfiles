From 00d7c2f358216927354752c82e79e73d0ab6928d Mon Sep 17 00:00:00 2001
From: Omar Sandoval <osandov@osandov.com>
Date: Sun, 10 Jan 2016 01:52:27 -0800
Subject: [PATCH 2/2] Add support for XBM icons in the status bar

This is done with an OSC escape code: "\e]9;icon path\a".
---
 drw.c | 51 ++++++++++++++++++++++++++++++++++++++++++++++++---
 drw.h |  4 ++--
 dwm.c | 17 +++++++++--------
 3 files changed, 59 insertions(+), 13 deletions(-)

diff --git a/drw.c b/drw.c
index 319eb6b..8c2ec52 100644
--- a/drw.c
+++ b/drw.c
@@ -235,7 +235,7 @@ drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int
 }
 
 int
-drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert)
+drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert, int escapes)
 {
 	char buf[1024];
 	int ty;
@@ -260,6 +260,8 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 	} else {
 		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
 		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColBg : ColFg].pixel);
+		XSetBackground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
 		d = XftDrawCreate(drw->dpy, drw->drawable,
 		                  DefaultVisual(drw->dpy, drw->screen),
 		                  DefaultColormap(drw->dpy, drw->screen));
@@ -273,6 +275,8 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 		utf8str = text;
 		nextfont = NULL;
 		while (*text) {
+			if (escapes && *text == '\x1b')
+				break;
 			utf8charlen = utf8decode(text, &utf8codepoint, UTF_SIZ);
 			for (curfont = drw->fonts; curfont; curfont = curfont->next) {
 				charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
@@ -318,6 +322,47 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 
 		if (!*text) {
 			break;
+		} else if (escapes && *text == '\x1b') {
+			char *c, *pt;
+			long ps;
+			Pixmap bm;
+			unsigned int bm_w, bm_h;
+			int bm_xh, bm_yh;
+			text++;
+			if (*text == ']') {
+				/* Operating System Control (OSC) */
+				text++;
+				ps = strtol(text, &c, 10);
+				if (*c != ';')
+					break;
+				if (ps == 9) {
+					/* Icon */
+					text = c + 1;
+					c = strchr(text, '\a');
+					if (!c)
+						break;
+					pt = malloc(c - text + 1);
+					if (pt) {
+						memcpy(pt, text, c - text);
+						pt[c - text] = '\0';
+						if (XReadBitmapFile(drw->dpy, drw->drawable, pt, &bm_w, &bm_h, &bm, &bm_xh, &bm_yh) == BitmapSuccess) {
+							if (render) {
+								ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
+								XCopyPlane(drw->dpy, bm, drw->drawable, drw->gc, 0, 0, bm_w, bm_h, x, ty - bm_h, 1);
+							}
+							XFreePixmap(drw->dpy, bm);
+							x += bm_w + 1;
+							w -= bm_w + 1;
+						}
+						free(pt);
+					}
+					text = c + 1;
+				} else {
+					break;
+				}
+			} else {
+				break;
+			}
 		} else if (nextfont) {
 			charexists = 0;
 			usedfont = nextfont;
@@ -375,11 +420,11 @@ drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h)
 }
 
 unsigned int
-drw_fontset_getwidth(Drw *drw, const char *text)
+drw_fontset_getwidth(Drw *drw, const char *text, int escapes)
 {
 	if (!drw || !drw->fonts || !text)
 		return 0;
-	return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
+	return drw_text(drw, 0, 0, 0, 0, 0, text, 0, escapes);
 }
 
 void
diff --git a/drw.h b/drw.h
index ff4355b..1414b9e 100644
--- a/drw.h
+++ b/drw.h
@@ -34,7 +34,7 @@ void drw_free(Drw *drw);
 /* Fnt abstraction */
 Fnt *drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount);
 void drw_fontset_free(Fnt* set);
-unsigned int drw_fontset_getwidth(Drw *drw, const char *text);
+unsigned int drw_fontset_getwidth(Drw *drw, const char *text, int escapes);
 void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h);
 
 /* Colorscheme abstraction */
@@ -51,7 +51,7 @@ void drw_setscheme(Drw *drw, Scm scm);
 
 /* Drawing functions */
 void drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert);
-int drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert);
+int drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert, int escapes);
 
 /* Map functions */
 void drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h);
diff --git a/dwm.c b/dwm.c
index b0d99c0..6f9a438 100644
--- a/dwm.c
+++ b/dwm.c
@@ -55,7 +55,8 @@
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
 #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
-#define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+#define TEXTW(X)                (drw_fontset_getwidth(drw, (X), 0) + lrpad)
+#define ETEXTW(X)               (drw_fontset_getwidth(drw, (X), 1) + lrpad)
 #define ColBorder               2
 
 /* enums */
@@ -237,7 +238,7 @@ static void zoom(const Arg *arg);
 
 /* variables */
 static const char broken[] = "broken";
-static char stext[256];
+static char stext[4096];
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh, blw = 0;      /* bar geometry */
@@ -440,7 +441,7 @@ buttonpress(XEvent *e)
 			arg.ui = 1 << i;
 		} else if (ev->x < x + blw)
 			click = ClkLtSymbol;
-		else if (ev->x > selmon->ww - TEXTW(stext))
+		else if (ev->x > selmon->ww - ETEXTW(stext))
 			click = ClkStatusText;
 		else
 			click = ClkWinTitle;
@@ -705,8 +706,8 @@ drawbar(Monitor *m)
 	/* draw status first so it can be overdrawn by tags later */
 	if (m == selmon) { /* status is only drawn on selected monitor */
 		drw_setscheme(drw, scheme[SchemeNorm]);
-		sw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
-		drw_text(drw, m->ww - sw, 0, sw, bh, 0, stext, 0);
+		sw = ETEXTW(stext) - lrpad + 2; /* 2px right padding */
+		drw_text(drw, m->ww - sw, 0, sw, bh, 0, stext, 0, 1);
 	}
 
 	for (c = m->clients; c; c = c->next) {
@@ -718,7 +719,7 @@ drawbar(Monitor *m)
 	for (i = 0; i < LENGTH(tags); i++) {
 		w = TEXTW(tags[i]);
 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
-		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i, 0);
 		if (occ & 1 << i)
 			drw_rect(drw, x + boxs, boxs, boxw, boxw,
 				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
@@ -727,12 +728,12 @@ drawbar(Monitor *m)
 	}
 	w = blw = TEXTW(m->ltsymbol);
 	drw_setscheme(drw, scheme[SchemeNorm]);
-	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0, 0);
 
 	if ((w = m->ww - sw - x) > bh) {
 		if (m->sel) {
 			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0, 0);
 			if (m->sel->isfloating)
 				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
 		} else {
-- 
2.15.0

